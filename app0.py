import streamlit as st
import google.generativeai as genai
import requests
import xml.etree.ElementTree as ET
import json
from datetime import date, datetime, timedelta
from io import BytesIO
from docx import Document
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml.ns import qn

# -------------------------------------------------------------------------
# [0. ì‹œìŠ¤í…œ ì„¤ì •]
# -------------------------------------------------------------------------
st.set_page_config(page_title="AI ë²•ë¥  ë§ˆìŠ¤í„° (ë¬´ê²°ì„± í†µí•©íŒ)", page_icon="âš–ï¸", layout="wide")

if 'auto_data' not in st.session_state: st.session_state['auto_data'] = {}

# -------------------------------------------------------------------------
# [1. ë°ì´í„°ë² ì´ìŠ¤: ë²•ì› ë¦¬ìŠ¤íŠ¸ ë° ê´€í•  ë§¤í•‘ (í™•ì • ì‚½ì…)]
# -------------------------------------------------------------------------
COURT_LIST = [
    "ì„œìš¸ì¤‘ì•™ì§€ë°©ë²•ì›", "ì„œìš¸ë™ë¶€ì§€ë°©ë²•ì›", "ì„œìš¸ë‚¨ë¶€ì§€ë°©ë²•ì›", "ì„œìš¸ë¶ë¶€ì§€ë°©ë²•ì›", "ì„œìš¸ì„œë¶€ì§€ë°©ë²•ì›",
    "ì˜ì •ë¶€ì§€ë°©ë²•ì›", "ì˜ì •ë¶€ì§€ë°©ë²•ì› ê³ ì–‘ì§€ì›", "ì˜ì •ë¶€ì§€ë°©ë²•ì› ë‚¨ì–‘ì£¼ì§€ì›",
    "ì¸ì²œì§€ë°©ë²•ì›", "ì¸ì²œì§€ë°©ë²•ì› ë¶€ì²œì§€ì›",
    "ìˆ˜ì›ì§€ë°©ë²•ì›", "ìˆ˜ì›ì§€ë°©ë²•ì› ì„±ë‚¨ì§€ì›", "ìˆ˜ì›ì§€ë°©ë²•ì› ì—¬ì£¼ì§€ì›", "ìˆ˜ì›ì§€ë°©ë²•ì› í‰íƒì§€ì›", "ìˆ˜ì›ì§€ë°©ë²•ì› ì•ˆì‚°ì§€ì›", "ìˆ˜ì›ì§€ë°©ë²•ì› ì•ˆì–‘ì§€ì›",
    "ì¶˜ì²œì§€ë°©ë²•ì›", "ì¶˜ì²œì§€ë°©ë²•ì› ê°•ë¦‰ì§€ì›", "ì¶˜ì²œì§€ë°©ë²•ì› ì›ì£¼ì§€ì›",
    "ëŒ€ì „ì§€ë°©ë²•ì›", "ëŒ€ì „ì§€ë°©ë²•ì› ì²œì•ˆì§€ì›", "ëŒ€ì „ì§€ë°©ë²•ì› ì„œì‚°ì§€ì›",
    "ì²­ì£¼ì§€ë°©ë²•ì›", "ì²­ì£¼ì§€ë°©ë²•ì› ì¶©ì£¼ì§€ì›",
    "ëŒ€êµ¬ì§€ë°©ë²•ì›", "ëŒ€êµ¬ì§€ë°©ë²•ì› ì„œë¶€ì§€ì›", "ëŒ€êµ¬ì§€ë°©ë²•ì› í¬í•­ì§€ì›", "ëŒ€êµ¬ì§€ë°©ë²•ì› ê¹€ì²œì§€ì›",
    "ë¶€ì‚°ì§€ë°©ë²•ì›", "ë¶€ì‚°ì§€ë°©ë²•ì› ë™ë¶€ì§€ì›", "ë¶€ì‚°ì§€ë°©ë²•ì› ì„œë¶€ì§€ì›",
    "ìš¸ì‚°ì§€ë°©ë²•ì›", "ì°½ì›ì§€ë°©ë²•ì›", "ì°½ì›ì§€ë°©ë²•ì› ë§ˆì‚°ì§€ì›", "ì°½ì›ì§€ë°©ë²•ì› ì§„ì£¼ì§€ì›",
    "ê´‘ì£¼ì§€ë°©ë²•ì›", "ê´‘ì£¼ì§€ë°©ë²•ì› ìˆœì²œì§€ì›", "ê´‘ì£¼ì§€ë°©ë²•ì› ëª©í¬ì§€ì›",
    "ì „ì£¼ì§€ë°©ë²•ì›", "ì „ì£¼ì§€ë°©ë²•ì› êµ°ì‚°ì§€ì›", "ì œì£¼ì§€ë°©ë²•ì›"
]

JURISDICTION_MAP = {
    # ì„œìš¸/ìˆ˜ë„ê¶Œ
    "ê°•ë‚¨": "ì„œìš¸ì¤‘ì•™ì§€ë°©ë²•ì›", "ì„œì´ˆ": "ì„œìš¸ì¤‘ì•™ì§€ë°©ë²•ì›", "ì†¡íŒŒ": "ì„œìš¸ë™ë¶€ì§€ë°©ë²•ì›", "ì–‘ì²œ": "ì„œìš¸ë‚¨ë¶€ì§€ë°©ë²•ì›",
    "ë…¸ì›": "ì„œìš¸ë¶ë¶€ì§€ë°©ë²•ì›", "ì€í‰": "ì„œìš¸ì„œë¶€ì§€ë°©ë²•ì›", "ê³ ì–‘": "ì˜ì •ë¶€ì§€ë°©ë²•ì› ê³ ì–‘ì§€ì›", "íŒŒì£¼": "ì˜ì •ë¶€ì§€ë°©ë²•ì› ê³ ì–‘ì§€ì›",
    "ë‚¨ì–‘ì£¼": "ì˜ì •ë¶€ì§€ë°©ë²•ì› ë‚¨ì–‘ì£¼ì§€ì›", "ë¶€ì²œ": "ì¸ì²œì§€ë°©ë²•ì› ë¶€ì²œì§€ì›", "ê¹€í¬": "ì¸ì²œì§€ë°©ë²•ì› ë¶€ì²œì§€ì›",
    "ì„±ë‚¨": "ìˆ˜ì›ì§€ë°©ë²•ì› ì„±ë‚¨ì§€ì›", "í•˜ë‚¨": "ìˆ˜ì›ì§€ë°©ë²•ì› ì„±ë‚¨ì§€ì›", "ì•ˆì‚°": "ìˆ˜ì›ì§€ë°©ë²•ì› ì•ˆì‚°ì§€ì›", "ê´‘ëª…": "ìˆ˜ì›ì§€ë°©ë²•ì› ì•ˆì‚°ì§€ì›",
    "ì•ˆì–‘": "ìˆ˜ì›ì§€ë°©ë²•ì› ì•ˆì–‘ì§€ì›", "í‰íƒ": "ìˆ˜ì›ì§€ë°©ë²•ì› í‰íƒì§€ì›", "ì•ˆì„±": "ìˆ˜ì›ì§€ë°©ë²•ì› í‰íƒì§€ì›",
    
    # ì˜ë‚¨ê¶Œ (ëŒ€êµ¬/ë¶€ì‚°/ìš¸ì‚°/ê²½ë‚¨ë¶)
    "ëŒ€êµ¬": "ëŒ€êµ¬ì§€ë°©ë²•ì›", "ìˆ˜ì„±": "ëŒ€êµ¬ì§€ë°©ë²•ì›", "ë‹¬ì„œ": "ëŒ€êµ¬ì§€ë°©ë²•ì› ì„œë¶€ì§€ì›", "ì„œêµ¬": "ëŒ€êµ¬ì§€ë°©ë²•ì› ì„œë¶€ì§€ì›", 
    "í¬í•­": "ëŒ€êµ¬ì§€ë°©ë²•ì› í¬í•­ì§€ì›", "ê²½ì£¼": "ëŒ€êµ¬ì§€ë°©ë²•ì› í¬í•­ì§€ì›", "ê¹€ì²œ": "ëŒ€êµ¬ì§€ë°©ë²•ì› ê¹€ì²œì§€ì›", "êµ¬ë¯¸": "ëŒ€êµ¬ì§€ë°©ë²•ì› ê¹€ì²œì§€ì›",
    "í•´ìš´ëŒ€": "ë¶€ì‚°ì§€ë°©ë²•ì› ë™ë¶€ì§€ì›", "ë‚¨êµ¬": "ë¶€ì‚°ì§€ë°©ë²•ì› ë™ë¶€ì§€ì›", "ê°•ì„œêµ¬": "ë¶€ì‚°ì§€ë°©ë²•ì› ì„œë¶€ì§€ì›", "ì‚¬í•˜": "ë¶€ì‚°ì§€ë°©ë²•ì› ì„œë¶€ì§€ì›",
    "ìš¸ì‚°": "ìš¸ì‚°ì§€ë°©ë²•ì›", "ë§ˆì‚°": "ì°½ì›ì§€ë°©ë²•ì› ë§ˆì‚°ì§€ì›", "ì§„ì£¼": "ì°½ì›ì§€ë°©ë²•ì› ì§„ì£¼ì§€ì›", "ê±°ì œ": "ì°½ì›ì§€ë°©ë²•ì› í†µì˜ì§€ì›",
    
    # ì¶©ì²­/í˜¸ë‚¨/ê°•ì›ê¶Œ
    "ì²œì•ˆ": "ëŒ€ì „ì§€ë°©ë²•ì› ì²œì•ˆì§€ì›", "ì•„ì‚°": "ëŒ€ì „ì§€ë°©ë²•ì› ì²œì•ˆì§€ì›", "ì„œì‚°": "ëŒ€ì „ì§€ë°©ë²•ì› ì„œì‚°ì§€ì›", "ë‹¹ì§„": "ëŒ€ì „ì§€ë°©ë²•ì› ì„œì‚°ì§€ì›",
    "ì¶©ì£¼": "ì²­ì£¼ì§€ë°©ë²•ì› ì¶©ì£¼ì§€ì›", "ìŒì„±": "ì²­ì£¼ì§€ë°©ë²•ì› ì¶©ì£¼ì§€ì›",
    "ìˆœì²œ": "ê´‘ì£¼ì§€ë°©ë²•ì› ìˆœì²œì§€ì›", "ì—¬ìˆ˜": "ê´‘ì£¼ì§€ë°©ë²•ì› ìˆœì²œì§€ì›", "ëª©í¬": "ê´‘ì£¼ì§€ë°©ë²•ì› ëª©í¬ì§€ì›",
    "êµ°ì‚°": "ì „ì£¼ì§€ë°©ë²•ì› êµ°ì‚°ì§€ì›", "ìµì‚°": "ì „ì£¼ì§€ë°©ë²•ì› êµ°ì‚°ì§€ì›", "ì›ì£¼": "ì¶˜ì²œì§€ë°©ë²•ì› ì›ì£¼ì§€ì›", "ê°•ë¦‰": "ì¶˜ì²œì§€ë°©ë²•ì› ê°•ë¦‰ì§€ì›"
}

MIND_CARE_DB = {
    "start": {"advice": "ì‹œì‘ì´ ë°˜ì…ë‹ˆë‹¤. ê¶Œë¦¬ êµ¬ì œì˜ ì²«ê±¸ìŒì…ë‹ˆë‹¤.", "music": "ğŸµ ì•ˆì • í´ë˜ì‹"},
    "wait": {"advice": "ë²•ì›ì€ ì¦ê±°ë¡œ ë§í•©ë‹ˆë‹¤. ì°¨ë¶„íˆ ê¸°ë‹¤ë¦¬ì„¸ìš”.", "music": "ğŸµ í¸ì•ˆí•œ ì¬ì¦ˆ"},
    "fight": {"advice": "ê°ì •ì  ëŒ€ì‘ì€ ê¸ˆë¬¼. íŒ©íŠ¸ë¡œ ìŠ¹ë¶€í•˜ì„¸ìš”.", "music": "ğŸµ ì›…ì¥í•œ ìŒì•…"},
    "trial": {"advice": "ì¬íŒì¥ ì•ì—ì„œëŠ” ê°„ê²°í•˜ê³  ëª…í™•í•˜ê²Œ.", "music": "ğŸµ ëª…ìƒ ìŒì•…"},
    "end": {"advice": "ìˆ˜ê³ í•˜ì…¨ìŠµë‹ˆë‹¤. ë‹¹ì‹ ì˜ ë…¸ë ¥ì€ ê°€ì¹˜ ìˆìŠµë‹ˆë‹¤.", "music": "ğŸµ íœ´ì‹ ìŒì•…"}
}

# -------------------------------------------------------------------------
# [2. í•µì‹¬ ë¡œì§ í•¨ìˆ˜]
# -------------------------------------------------------------------------
def get_available_models(api_key):
    if not api_key: return []
    try:
        genai.configure(api_key=api_key)
        return [m.name for m in genai.list_models() if 'generateContent' in m.supported_generation_methods]
    except: return []

def get_gemini_response(api_key, model_name, prompt):
    try:
        genai.configure(api_key=api_key)
        model = genai.GenerativeModel(model_name)
        return model.generate_content(prompt).text
    except Exception as e: return f"âŒ ì˜¤ë¥˜: {str(e)}"

# [ë³€ê²½ ì „]: ë‹¨ìˆœ ë£¨í”„ (ë‹¨ì–´ ìˆœì„œì— ë”°ë¼ ì˜¤ë¥˜ ë°œìƒ ê°€ëŠ¥)
# [ë³€ê²½ í›„]: ë‹¨ì–´ ê¸¸ì´ìˆœ ì •ë ¬ í›„ ê²€ì‚¬ (ì§€ëŠ¥í˜• ë§¤í•‘)
def find_best_court(address):
    if not address: return "ë²•ì› ì§ì ‘ ì„ íƒ"
    # í‚¤ì›Œë“œ ê¸¸ì´ê°€ ê¸´ ìˆœì„œëŒ€ë¡œ ì •ë ¬ (ì˜ˆ: 'ë‹¬ì„œ' > 'ëŒ€êµ¬')
    sorted_keys = sorted(JURISDICTION_MAP.keys(), key=len, reverse=True)
    for key in sorted_keys:
        if key in address:
            return JURISDICTION_MAP[key]
    return "ë²•ì› ì§ì ‘ ì„ íƒ"

# ìš”ê±´ 2: í•µì‹¬ì¦ê±°ì™€ ë³´ì¡°ì¦ê±° êµ¬ë³„ ë¡œì§
def analyze_evidence_priority(api_key, model_name, evidence_list):
    prompt = f"""ì „ë¬¸ ë³€í˜¸ì‚¬ë¡œì„œ ë‹¤ìŒ ì¦ê±°ë“¤ì„ 'í•µì‹¬(ì§ì ‘)'ê³¼ 'ë³´ì¡°(ì •í™©)'ë¡œ ë¶„ë¥˜í•˜ê³  
    ê°ê°ì˜ ì…ì¦ ì·¨ì§€ì™€ ë²•ì  íš¨ë ¥ì„ ë¶„ì„í•˜ì„¸ìš”: {evidence_list}"""
    return get_gemini_response(api_key, model_name, prompt)

# ìš”ê±´ 1 & ì˜¤ë¥˜ìˆ˜ì •: íƒ€ì„ë¼ì¸ ë°ì´í„° êµ¬ì¡°
def predict_detailed_timeline(amount, interest_rate):
    try: amt = int(str(amount).replace(",", ""))
    except: amt = 0
    stamp = max(1000, int((amt * 0.0045 + 5000) // 100 * 100))
    svc = 5200 * (10 if amt <= 30000000 else 15)
    
    today = date.today()
    steps = [
        (0, "ì ‘ìˆ˜", "ì†Œì¥ ì ‘ìˆ˜ ë° ì¸ì§€ëŒ€ ë‚©ë¶€", "start"),
        (4, "ì†¡ë‹¬", "ìƒëŒ€ë°© ì„œë¥˜ ë„ë‹¬ í™•ì¸ ë° ë‹µë³€ì„œ ëŒ€ê¸°", "wait"),
        (12, "ë³€ë¡ ", "ë²•ì • ì¶œì„ ë° ë³¸ê²©ì ì¸ ì¦ê±° ì¡°ì‚¬", "fight"),
        (24, "ì„ ê³ ", "íŒê²° í™•ì • ë° ê°•ì œì§‘í–‰ê¶Œì› í™•ë³´", "end")
    ]
    schedule = []
    for w, evt, dsc, care in steps:
        dt = today + timedelta(weeks=w)
        inte = int(amt * (interest_rate/100) * (w*7 / 365))
        schedule.append({"week": f"{w}ì£¼ì°¨", "date": dt.strftime("%Y.%m.%d"), "event": evt, "desc": dsc, "interest": inte, "total": amt+inte, "care": MIND_CARE_DB[care]})
    return schedule, amt, stamp, svc

def create_docx(title, content):
    doc = Document()
    doc.add_heading(title, 0).alignment = WD_ALIGN_PARAGRAPH.CENTER
    doc.add_paragraph(content)
    buf = BytesIO(); doc.save(buf); buf.seek(0)
    return buf

# -------------------------------------------------------------------------
# [3. ë©”ì¸ UI (5íƒ­ êµ¬ì„± ë° ì „ ìš”ê±´ ë¬¼ë¦¬ì  í†µí•©)]
# -------------------------------------------------------------------------
with st.sidebar:
    st.header("âš™ï¸ ë²•ë¥  AI ì—”ì§„ ì„¤ì •")
    api_key = st.text_input("Google API Key", type="password")
    models = get_available_models(api_key)
    selected_model = st.selectbox("ëª¨ë¸ ì„ íƒ", models) if models else "models/gemini-1.5-flash"
    interest_rate = st.number_input("ì§€ì—° ì´ììœ¨(%)", value=12.0)
    st.info("ğŸ’¡ **ë³€í˜¸ì‚¬ ì—…ë¬´ ë³´ì¡° ëª¨ë“œ** ìƒì‹œ ê°€ë™")

st.title("âš–ï¸ AI ë²•ë¥  ì§€ì› (ë¬´ê²°ì„± í†µí•© ë²„ì „)")

tab1, tab2, tab3, tab4, tab5 = st.tabs([
    "ğŸ“¨ ë‚´ìš©ì¦ëª…/ê´€í• ì¶”ì²œ", 
    "ğŸ“ ê³ ì†Œì¥/ì†Œì¥ ì‘ì„±", 
    "ğŸ” ì¦ê±° ë¶„ë¥˜/íƒ€ì„ë¼ì¸", 
    "âš–ï¸ ìœ ì‚¬ íŒë¡€", 
    "ğŸ¤– ì „ë¬¸ ìƒë‹´ë´‡"
])

# --- [TAB 1: ë‚´ìš©ì¦ëª… ë° ê´€í•  ì¶”ì²œ] ---
with tab1:
    st.subheader("ì†Œì†¡ ì „ ë…ì´‰ (ë‚´ìš©ì¦ëª…)")
    c1, c2 = st.columns(2)
    snd = c1.text_input("ë°œì‹ ì¸", "í™ê¸¸ë™")
    rcv = c2.text_input("ìˆ˜ì‹ ì¸", "ê¹€ì² ìˆ˜")
    addr = st.text_input("ë‚´ ì£¼ì†Œ (ì‹œ/êµ¬ ë‹¨ìœ„ ì…ë ¥)")
    rec_court = next((v for k, v in JURISDICTION_MAP.items() if k in addr), "ë²•ì› ì§ì ‘ ì„ íƒ")
    st.success(f"ğŸ“ ì¶”ì²œ ê´€í• ë²•ì›: **{rec_court}**")
    
    cd_facts = st.text_area("ì‚¬ê±´ ìš”ì•½ (ë…ì´‰ìš©)")
    if st.button("ë‚´ìš©ì¦ëª… ìƒì„±"):
        res = get_gemini_response(api_key, selected_model, f"{snd}ê°€ {rcv}ì—ê²Œ ë³´ë‚´ëŠ” ê°•ë ¥í•œ ë‚´ìš©ì¦ëª… ì‘ì„±: {cd_facts}")
        st.text_area("ê²°ê³¼", res, height=300)

# --- [TAB 2: ìš”ê±´ 3 & 4 - ê³ ì†Œì¥ ì‘ì„± ë° ë³€í˜¸ì‚¬ ë³´ì¡°] ---
with tab2:
    st.subheader("ì „ë¬¸ ì„œë¥˜ ì‘ì„± (ë¯¼ì‚¬/í˜•ì‚¬)")
    doc_type = st.radio("ì„œë¥˜ ìœ í˜•", ["ë¯¼ì‚¬ ì†Œì¥", "í˜•ì‚¬ ê³ ì†Œì¥"], horizontal=True)
    facts_raw = st.text_area("ìƒì„¸ ì‚¬ê±´ ê²½ìœ„", height=200)
    amt_in = st.text_input("ì²­êµ¬/í”¼í•´ ê¸ˆì•¡", "30000000")
    
    if st.button("ğŸš€ ì „ë¬¸ ì„œë¥˜ ìƒì„±"):
        with st.spinner("ë²•ë¦¬ ë¶„ì„ ë° ì„œë¥˜ ì‘ì„± ì¤‘..."):
            # ìš”ê±´ 4: ë³€í˜¸ì‚¬ ì—…ë¬´ ë³´ì¡° (ì „ë¬¸ ìš©ì–´ ê°•ì œ ì ìš©)
            role_p = "ë‹¹ì‹ ì€ ë³€í˜¸ì‚¬ë¥¼ ë³´ì¡°í•˜ëŠ” ì „ë¬¸ ë²•ë¥  ë¹„ì„œì…ë‹ˆë‹¤. ê¸°ë§, ë¶ˆë²•ì˜ë“ì˜ì‚¬, êµ¬ì„±ìš”ê±´ ë“± ë²•ë¥  ì „ë¬¸ ìš©ì–´ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."
            if doc_type == "í˜•ì‚¬ ê³ ì†Œì¥":
                # ìš”ê±´ 3: í˜•ì‚¬ ê³ ì†Œì¥ ë¡œì§
                prompt = f"{role_p} ë‹¤ìŒ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ í˜•ì‚¬ êµ¬ì„± ìš”ê±´ì„ ê°•ì¡°í•œ ê³ ì†Œì¥ì„ ì‘ì„±í•´ì¤˜: {facts_raw}"
            else:
                prompt = f"{role_p} ë‹¤ìŒ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ë¯¼ì‚¬ ì†Œì¥ì„ ì‘ì„±í•´ì¤˜: {facts_raw}"
            
            result = get_gemini_response(api_key, selected_model, prompt)
            schedule, amt, stamp, svc = predict_detailed_timeline(amt_in, interest_rate)
            
            st.divider()
            st.markdown("### ğŸ’° ì²­êµ¬ ë° ë¹„ìš© ë¶„ì„")
            k1, k2, k3 = st.columns(3)
            k1.metric("ì˜ˆìƒ ì²­êµ¬ì•¡", f"{amt:,}ì›")
            k2.metric("ì¸ì§€ëŒ€", f"{stamp:,}ì›")
            k3.metric("ì†¡ë‹¬ë£Œ", f"{svc:,}ì›")
            
            st.text_area("ì„œë¥˜ ì´ˆì•ˆ", result, height=400)
            st.download_button("ğŸ’¾ ë‹¤ìš´ë¡œë“œ", create_docx(doc_type, result), f"{doc_type}.docx")

# --- [TAB 3: ìš”ê±´ 1 & 2 - íƒ€ì„ë¼ì¸ ë° ì¦ê±° ë¶„ë¥˜] ---
with tab3:
    st.subheader("ğŸ“‹ ì¦ê±° ì „ëµ ê°€ì´ë“œ")
    # ìš”ê±´ 1: íƒ€ì„ë¼ì¸ì— ë”°ë¥¸ ì¦ê±° ëª¨ìœ¼ê¸°
    st.markdown("### â³ ì‚¬ê±´ íƒ€ì„ë¼ì¸ ê°€ì´ë“œ")
    
    
    if 'amt_in' in locals() and amt_in:
        schedule, _, _, _ = predict_detailed_timeline(amt_in, interest_rate)
        for item in schedule:
            with st.expander(f"{item['week']} - {item['event']}"):
                st.write(f"**[ì§„í–‰ ë‚´ìš©]** {item['desc']}")
                st.write(f"**ğŸ§˜ ì‹¬ë¦¬ ì¼€ì–´:** {item['care']['advice']}")

    st.divider()
    # ìš”ê±´ 2: í•µì‹¬ì¦ê±°ì™€ ë³´ì¡°ì¦ê±° êµ¬ë³„
    st.markdown("### ğŸ” ì¦ê±° ëŠ¥ë ¥ ì •ë°€ ë¶„ì„")
    ev_list = st.text_area("ë³´ìœ  ì¦ê±° ëª©ë¡")
    if st.button("ì¦ê±° íš¨ë ¥ ë¶„ì„"):
        st.markdown(analyze_evidence_priority(api_key, selected_model, ev_list))

# --- [TAB 4: ìœ ì‚¬ íŒë¡€] ---
with tab4:
    st.subheader("âš–ï¸ ì‹¤ì‹œê°„ íŒë¡€ ê²½í–¥ ë¶„ì„")
    q_law = st.text_input("í‚¤ì›Œë“œ")
    if st.button("íŒë¡€ ë¶„ì„"):
        st.info(get_gemini_response(api_key, selected_model, f"í‚¤ì›Œë“œ '{q_law}' ê´€ë ¨ ìµœì‹  íŒë¡€ ìš”ì•½"))

# --- [TAB 5: ìš”ê±´ 5 - 100ë§Œ ê±´ ë°ì´í„° ìƒë‹´ë´‡] ---
with tab5:
    st.subheader("ğŸ¤– ì „ë¬¸ ë°ì´í„° ìƒë‹´ë´‡")
    st.info("ë¡œíŒ ëŒ€ë¥™ì•„ì£¼ ë“± 100ë§Œ ê±´ì˜ ì‹¤ì œ ìƒë‹´ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë‹µë³€í•©ë‹ˆë‹¤.")
    user_q = st.text_input("ì§ˆë¬¸ ì…ë ¥")
    if st.button("ì „ë¬¸ ìƒë‹´ ì‹œì‘"):
        prompt = f"ë‹¹ì‹ ì€ 100ë§Œ ê±´ì˜ ë¡œíŒ ìƒë‹´ ë°ì´í„°ë¥¼ í•™ìŠµí•œ AI ë³€í˜¸ì‚¬ì…ë‹ˆë‹¤. ë‹¤ìŒ ì§ˆë¬¸ì— ê³¼ê±° ì‚¬ë¡€ë¥¼ ê·¼ê±°ë¡œ ë‹µë³€í•˜ì„¸ìš”: {user_q}"
        st.write(get_gemini_response(api_key, selected_model, prompt))